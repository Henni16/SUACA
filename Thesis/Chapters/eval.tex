In this chapter we are going to show some example runs of \iaca, \suaca\ and one of \osaca. We will evaluate the results and differences of the tools and show how an detailed analysis can be done with \suaca.

\section{Bottleneck analysis}

Consider the following example run of \iaca\ $2.3$ on the Sandy Bridge architecture:

\begin{example}
        Throughput Analysis Report
        --------------------------
        Block Throughput: 2.00 Cycles       Throughput Bottleneck: FrontEnd
        
        Port Binding In Cycles Per Iteration:
        -------------------------------------------------------------------------
        |  Port  |  0   -  DV  |  1   |  2   -  D   |  3   -  D   |  4   |  5   |
        -------------------------------------------------------------------------
        | Cycles | 2.0    0.0  | 2.0  | 0.0    0.0  | 0.0    0.0  | 0.0  | 2.0  |
        -------------------------------------------------------------------------
        
        N - port number or number of cycles resource conflict caused delay, DV - Divider pipe (on port 0)
        D - Data fetch pipe (on ports 2 and 3), CP - on a critical path
        F - Macro Fusion with the previous instruction occurred
        * - instruction micro-ops not bound to a port
        ^ - Micro Fusion happened
        # - ESP Tracking sync uop was issued
        @ - SSE instruction followed an AVX256/AVX512 instruction, dozens of cycles penalty is expected
        X - instruction not supported, was not accounted in Analysis
        
        | Num Of |              Ports pressure in cycles               |    |
        |  Uops  |  0  - DV  |  1  |  2  -  D  |  3  -  D  |  4  |  5  |    |
        ---------------------------------------------------------------------
        |   1    | 1.0       |     |           |           |     |     | CP | mov rax, 0x6
        |   1    |           | 1.0 |           |           |     |     | CP | mov rax, 0x6
        |   1    |           |     |           |           |     | 1.0 | CP | mov rax, 0x6
        |   1    | 1.0       |     |           |           |     |     | CP | mov rax, 0x6
        |   1    |           | 1.0 |           |           |     |     | CP | mov rax, 0x6
        |   1    |           |     |           |           |     | 1.0 | CP | mov rax, 0x6
        Total Num Of Uops: 6
\end{example}

Note that we constructed this program exclusively for our purposes. In reality the processor would only execute the first instruction and completely optimize the rest away. This is fine as none of the tools will simulate this behavior and it is designed as a toy example.\\
We can observe that the \emph{mov} instruction is able to use ports $0$, $1$ and $5$. The front end of the Sandy Bridge architecture can deliver up to four \microops\ per cycle and there are no dependencies as no register is ever read.\\
So the clear bottleneck of this program are the three ports, because four \microops\ get loaded but only three ports are available for their execution. Unfortunately we don't know how the bottleneck analysis of \iaca\ works so we can't argue why it believes that the front end might be the bottleneck. Looking at the information we do have it does not make sense, though.\\


Now consider \suaca's output of the same program with $200$ iterations:

\begin{example}
Block throughput: 2.00 cycles
Block throughput with perfect front end: 2.00 cycles
Block throughput with infinitely usable ports: 1.50 cycles
Block throughput without dependencies: 2.00 cycles
Microops per cycle: 3.00
       
Analysis for architecture: SNB
        
 Line  ||   Num   ||   had   || caused  ||            Used Ports
       ||   Uops  || to wait || to wait ||   0   ||   1   ||   2   ||   3   ||   4   ||   5   ||
 ------------------------------------------------------------------------------------------------
   0   ||    1    ||  15.6   ||  46.7   ||  1.0  ||       ||       ||       ||       ||       || mov rax, 0x6
   1   ||    1    ||  15.6   ||  46.7   ||       ||  1.0  ||       ||       ||       ||       || mov rax, 0x6
   2   ||    1    ||  15.5   ||  46.7   ||       ||       ||       ||       ||       ||  1.0  || mov rax, 0x6
   3   ||    1    ||  15.6   ||  46.7   ||  1.0  ||       ||       ||       ||       ||       || mov rax, 0x6
   4   ||    1    ||  15.6   ||  46.7   ||       ||  1.0  ||       ||       ||       ||       || mov rax, 0x6
   5   ||    1    ||  15.6   ||  46.7   ||       ||       ||       ||       ||       ||  1.0  || mov rax, 0x6
Total number of Uops: 6
\end{example}

One can easily see that the port information and the block throughput is identical to \iaca's output. The major difference lies in the bottleneck analysis. \suaca\ tells you that the throughput improves quite drastically with infinitely usable ports. The two cycles make sense with the ports in consideration as we have three usable ports and six instructions, but when each port can be used to an infinite amount each cycle this is no longer relevant. Without the port problem we only need one and a half cycle for each iteration as we have six \microops\ and a front end that produces four of them each cycle.\\
We can also tell \suaca\ to analyze a specific line for us:

\begin{example}
Detailed delay information for instruction: mov rax, 0x6 in line 0
    
            Maximum latency: 1
            
            Latencies for dependencies:
            This instruction doesn't have any dependencies!
                      
            Delay caused by blocked ports:
             Port || was delayed || has delayed
             ----------------------------------
              0   ||    46.7     ||    15.6
              1   ||     0.0     ||    15.6
              5   ||     0.0     ||    15.6
\end{example}

In this particular case the detailed analysis is identical for every line, because the number of loads per cycle doesn't divide the total number of \microops\ the program kind of ``rotates'' during the simulation. A high number of iterations therefore leads to, on average, equal number of all instructions.\\
This detailed analysis shows that each line suffered a delay of $15.6$ cycles from each of its usable ports. This value is equal for all ports, because this instruction only consists of a single \microop\ and is therefore only delayed if all three ports are blocked (see algorithm \ref{alg:assign}), which will then all be held responsible. Each instruction causes a delay on the port it used.\\
The \emph{caused to wait} value in the original output is thrice as high as the \emph{had to wait} value. This is due to the fact that there are always three instructions that are responsible for a single other instruction's delay.\\

Unfortunately, \osaca\ does not offer a bottleneck analysis which makes this comparison obsolete.


\section{Complete analysis}

Now we are going to analyze the example provided by the \osaca\ thesis \cite{osaca-thesis}. First consider the underlaying \emph{C} code which represents a 2D-5pt stencil:


\begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=1,innerbottommargin=1, outerlinewidth=1, linecolor=light-gray]
    \begin{lstlisting}[language=C, basicstyle=\scriptsize]
for(j = 1; j < M-1; ++j){
    #pragma vector aligned
    for(int i = 1; i < N-1; ++i){
        (*@\textcolor{Green}{IACA\_START}  @*)
        b[j][i] = (a[j][i-1] + a[j][i+1] + a[j-1][i] + a[j+1][i]) * s;
    }
    (*@\textcolor{Green}{IACA\_END}  @*)
}
    \end{lstlisting}
\end{mdframed}

In the following we will analyze the resulting machine code and compare the results of \iaca, \osaca\ and \suaca. We will do so with the Ivy Bridge microarchitecture in mind. First consider \osaca's analysis in \exref{osaca}. We can observe a different approach to the port bindings here. \osaca\ always tries to distribute the port pressure evenly across all ports to an extend where it doesn't take previous instructions into account. This basically means, that every instruction will always have the same port bindings no matter how the rest of the program looks like. The idea is to give the user more information about possible bindings which are hard to observe when using \iaca. However, this leads to an overestimation of the throughput as the pressure on port $1$ is much higher than it needs to be. The \emph{incq} and \emph{cmpq} instructions do not need to use port $1$ at all.


\begin{LabeledExample}{\osaca\ run}{osaca}
    Throughput Analysis Report
    --------------------------
    X - No information for this instruction in data file
    " - Instruction micro-ops not bound to a port
    
    Port Binding in Cycles Per Iteration:
    -------------------------------------------------
    | Port   |   0  |   1  |  2  |  3  |  4  |   5  |
    -------------------------------------------------
    | Cycles | 1.67 | 3.67 | 2.5 | 2.5 | 1.0 | 0.67 |
    -------------------------------------------------
    
    Ports Pressure in cycles
    |   0  |   1  |   2  |   3  |   4  |   5  |
    -------------------------------------------
    |      |      | 0.50 | 0.50 |      |      | vmovsd  (%r14,%r15,8), %xmm2
    |      | 1.00 | 0.50 | 0.50 |      |      | vaddsd  16(%r14,%r15,8), %xmm2, %xmm3
    |      | 1.00 | 0.50 | 0.50 |      |      | vaddsd  8(%rax,%r15,8), %xmm3, %xmm4
    |      | 1.00 | 0.50 | 0.50 |      |      | vaddsd  8(%rdx,%r15,8), %xmm4, %xmm5
    | 1.00 |      |      |      |      |      | vmulsd  %xmm5, %xmm1, %xmm6
    |      |      | 0.50 | 0.50 | 1.00 |      | vmovsd  %xmm6, 8(%r12,%r15,8)
    | 0.33 | 0.33 |      |      |      | 0.33 | incq    %r15
    | 0.33 | 0.33 |      |      |      | 0.33 | cmpq    %r13, %r15
    |      |      |      |      |      |      | jb      ..B1.17
    Total number of estimated throughput: 4.67
\end{LabeledExample}

The \osaca\ thesis states, that we can conclude that port $1$ is the bottleneck of this program, which makes sense looking at the given analysis, but we will now look into the program a bit further.


\begin{LabeledExample}{\iaca\ run}{iaca}
  Throughput Analysis Report
  --------------------------
  Block Throughput: 3.00 Cycles       Throughput Bottleneck: FrontEnd
  
  Port Binding In Cycles Per Iteration:
  -------------------------------------------------------------------------
  |  Port  |  0   -  DV  |  1   |  2   -  D   |  3   -  D   |  4   |  5   |
  -------------------------------------------------------------------------
  | Cycles | 1.0    0.0  | 3.0  | 2.5    2.0  | 2.5    2.0  | 1.0  | 2.0  |
  -------------------------------------------------------------------------
  
      
  | Num Of |              Ports pressure in cycles               |    |
  |  Uops  |  0  - DV  |  1  |  2  -  D  |  3  -  D  |  4  |  5  |    |
  ---------------------------------------------------------------------
  |   1    |           |     | 1.0   1.0 |           |     |     |    | vmovsd xmm2, qword ptr [r14+r15*8]
  |   2    |           | 1.0 |           | 1.0   1.0 |     |     | CP | vaddsd xmm3, xmm2, qword ptr [r14+r15*8+0x10]
  |   2    |           | 1.0 | 1.0   1.0 |           |     |     | CP | vaddsd xmm4, xmm3, qword ptr [rax+r15*8+0x8]
  |   2    |           | 1.0 |           | 1.0   1.0 |     |     | CP | vaddsd xmm5, xmm4, qword ptr [rdx+r15*8+0x8]
  |   1    | 1.0       |     |           |           |     |     |    | vmulsd xmm6, xmm1, xmm5
  |   2    |           |     | 0.5       | 0.5       | 1.0 |     |    | vmovsd qword ptr [r12+r15*8+0x8], xmm6
  |   1    |           |     |           |           |     | 1.0 |    | inc r15
  |   1    |           |     |           |           |     | 1.0 |    | cmp r15, r13
  Total Num Of Uops: 12
\end{LabeledExample}

\exref{iaca}














