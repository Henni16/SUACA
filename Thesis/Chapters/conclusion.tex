This work introduced \suaca, a tool that is able to compute the port bindings, latency and throughput of an \emph{x86} assembly program. It will also give hints at the bottleneck as well as several ways to further investigate what the bottleneck might be. Read-After-Write dependencies between instructions are tracked for all register operands, including the suppressed ones and those that are used to access memory, and with respect to the control flow. It supports most currently available Intel microarchitectures and can easily be updated to support future ones.\\

One thing that \suaca\ does not support yet are macro and micro op fusions as well as the data fetch pipes of certain ports.\\
Macro op fusion usually ``eliminates'' the last jump instruction of a loop body by merging it into the prior instruction. This would probably require some hard coded information about the macro-fusible instructions of each microarchitecture.\\
\iaca\ displays the data fetch pipes on (usually) ports $2$ and $3$. Those pipes are used when the respective instructions loads from memory. At the moment it remains unclear when and if those values have an impact on the throughput of a program. That is why we have not implemented it so far.\\
What could be considered is an improved simulation of the front-end as well as support for zero latency instructions. At the moment we are always loading the maximum number of \microops\ into the scheduler. This is most certainly not perfectly accurate, but this improvement would require measurements of the front-end. Some instructions are so called ``zero latency instructions'' in \emph{x86}. Those can be eliminated by the front-end and will therefore not affect the execution. So far \suaca executes them with a latency of a single cycle.\\
The simulation of \emph{AMD} microarchitectures could also be considered, but it would require fundamental changes both to the measurements and \suaca\ itself.\\
The bottleneck analyses could also be extended. One example would be increasing the amount of \microops\ a certain port can handle each cycle instead of simply setting this amount to infinite for all ports.\\
In \emph{x86} a floating point operation followed by an integer operation on the same register (or vice versa) causes a so called ``bypass delay''. At the time of writing \suaca\ does not consider these delays.\\

\suaca\ also has some limitations that either cannot be overcome without internal information or high additional effort.
The most important one is precise information about the \microops. We could remarkably improve our computations as we would eliminate the issues described in \autoref{sec:chooseport}. Another integral part of our computations is the algorithm of the reservation station. We assumed a greedy algorithm, which might not be perfectly accurate. Implementing the correct algorithm would also bring our results closer to reality.\\
In some corner cases it would be possible to keep track of the memory during the dependency analysis. However, it is impossible most of the time as we are performing a static analysis. Because a memory access usually uses a register and we would therefore need to know the actual values inside the registers.\\

